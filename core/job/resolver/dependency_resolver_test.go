package resolver_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/net/context"

	"github.com/odpf/optimus/core/job"
	"github.com/odpf/optimus/core/job/dto"
	"github.com/odpf/optimus/core/job/resolver"
	"github.com/odpf/optimus/core/tenant"
	"github.com/odpf/optimus/models"
)

func TestDependencyResolver(t *testing.T) {
	ctx := context.Background()
	project, _ := tenant.NewProject("test-proj",
		map[string]string{
			"bucket":                     "gs://some_folder-2",
			tenant.ProjectSchedulerHost:  "host",
			tenant.ProjectStoragePathKey: "gs://location",
		})
	namespace, _ := tenant.NewNamespace("test-ns", project.Name(),
		map[string]string{
			"bucket": "gs://ns_bucket",
		})
	sampleTenant, _ := tenant.NewTenant(project.Name().String(), namespace.Name().String())
	externalTenant, _ := tenant.NewTenant("external-proj", "external-namespace")
	jobVersion := 1
	jobSchedule := job.NewSchedule("2022-10-01", "", "", false, false, nil)
	jobWindow, _ := models.NewWindow(jobVersion, "d", "24h", "24h")
	jobTaskConfig := job.NewConfig(map[string]string{"sample_task_key": "sample_value"})
	jobTask := job.NewTask("bq2bq", jobTaskConfig)

	t.Run("Resolve", func(t *testing.T) {
		t.Run("resolve dependency internally", func(t *testing.T) {
			jobRepo := NewJobRepository(t)
			externalDependencyResolver := NewExternalDependencyResolver(t)

			jobSpecA, err := job.NewJobSpec(sampleTenant, jobVersion, "job-A", "", "", nil, jobSchedule,
				jobWindow, jobTask, nil, nil, nil, nil, nil)
			assert.Nil(t, err)
			jobADestination := "resource-A"
			jobADependencies := []string{"resource-B"}

			jobA := job.NewJob(jobSpecA, jobADestination, jobADependencies)
			jobs := []*job.Job{jobA}

			dependency := dto.NewDependency("job-B", sampleTenant, "", "resource-B")
			dependencies := []*dto.Dependency{dependency}
			jobWithDependencies := []*job.WithDependency{job.NewWithDependency(jobSpecA.Name(), project.Name(), dependencies, nil)}
			jobRepo.On("GetJobWithDependencies", ctx, project.Name(), []job.Name{jobSpecA.Name()}).Return(jobWithDependencies, nil)

			externalDependencyResolver.On("FetchExternalDependencies", ctx, mock.Anything).Return([]*dto.Dependency{}, nil, nil)

			expectedJobWithDependencies := []*job.WithDependency{job.NewWithDependency(jobSpecA.Name(), project.Name(), []*dto.Dependency{dependency}, nil)}

			dependencyResolver := resolver.NewDependencyResolver(jobRepo, externalDependencyResolver)
			result, err := dependencyResolver.Resolve(ctx, jobs)
			assert.Nil(t, err)
			assert.EqualValues(t, expectedJobWithDependencies, result)
		})
		t.Run("resolve dependency internally and externally", func(t *testing.T) {
			jobRepo := NewJobRepository(t)
			externalDependencyResolver := NewExternalDependencyResolver(t)

			dependencySpec := job.NewDependencySpec([]string{"job-c"}, nil)
			jobSpecA, err := job.NewJobSpec(sampleTenant, jobVersion, "job-A", "", "", nil, jobSchedule,
				jobWindow, jobTask, nil, nil, dependencySpec, nil, nil)
			assert.Nil(t, err)
			jobADestination := "resource-A"
			jobADependencies := []string{"resource-B"}

			jobA := job.NewJob(jobSpecA, jobADestination, jobADependencies)
			jobs := []*job.Job{jobA}

			internalDependency := dto.NewDependency("job-B", sampleTenant, "", "resource-B")
			jobWithDependencies := []*job.WithDependency{job.NewWithDependency(jobSpecA.Name(), project.Name(), []*dto.Dependency{internalDependency}, nil)}
			jobRepo.On("GetJobWithDependencies", ctx, project.Name(), []job.Name{jobSpecA.Name()}).Return(jobWithDependencies, nil)

			externalDependency := dto.NewDependency("job-C", externalTenant, "external-host", "resource-C")
			externalDependencyResolver.On("FetchExternalDependencies", ctx, mock.Anything).Return([]*dto.Dependency{externalDependency}, nil, nil)

			expectedJobWithDependencies := []*job.WithDependency{
				job.NewWithDependency(jobSpecA.Name(), project.Name(), []*dto.Dependency{internalDependency, externalDependency}, nil),
			}

			dependencyResolver := resolver.NewDependencyResolver(jobRepo, externalDependencyResolver)
			result, err := dependencyResolver.Resolve(ctx, jobs)
			assert.Nil(t, err)
			assert.EqualValues(t, expectedJobWithDependencies, result)
		})
	})
}

// ExternalDependencyResolver is an autogenerated mock type for the ExternalDependencyResolver type
type ExternalDependencyResolver struct {
	mock.Mock
}

// FetchExternalDependencies provides a mock function with given fields: ctx, unresolvedDependencies
func (_m *ExternalDependencyResolver) FetchExternalDependencies(ctx context.Context, unresolvedDependencies []*dto.UnresolvedDependency) ([]*dto.Dependency, []*dto.UnresolvedDependency, error) {
	ret := _m.Called(ctx, unresolvedDependencies)

	var r0 []*dto.Dependency
	if rf, ok := ret.Get(0).(func(context.Context, []*dto.UnresolvedDependency) []*dto.Dependency); ok {
		r0 = rf(ctx, unresolvedDependencies)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dto.Dependency)
		}
	}

	var r1 []*dto.UnresolvedDependency
	if rf, ok := ret.Get(1).(func(context.Context, []*dto.UnresolvedDependency) []*dto.UnresolvedDependency); ok {
		r1 = rf(ctx, unresolvedDependencies)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*dto.UnresolvedDependency)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []*dto.UnresolvedDependency) error); ok {
		r2 = rf(ctx, unresolvedDependencies)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

type mockConstructorTestingTNewExternalDependencyResolver interface {
	mock.TestingT
	Cleanup(func())
}

// NewExternalDependencyResolver creates a new instance of ExternalDependencyResolver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewExternalDependencyResolver(t mockConstructorTestingTNewExternalDependencyResolver) *ExternalDependencyResolver {
	mock := &ExternalDependencyResolver{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// JobRepository is an autogenerated mock type for the JobRepository type
type JobRepository struct {
	mock.Mock
}

// GetJobWithDependencies provides a mock function with given fields: ctx, projectName, jobNames
func (_m *JobRepository) GetJobWithDependencies(ctx context.Context, projectName tenant.ProjectName, jobNames []job.Name) ([]*job.WithDependency, error) {
	ret := _m.Called(ctx, projectName, jobNames)

	var r0 []*job.WithDependency
	if rf, ok := ret.Get(0).(func(context.Context, tenant.ProjectName, []job.Name) []*job.WithDependency); ok {
		r0 = rf(ctx, projectName, jobNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*job.WithDependency)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, tenant.ProjectName, []job.Name) error); ok {
		r1 = rf(ctx, projectName, jobNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Save provides a mock function with given fields: ctx, jobs
func (_m *JobRepository) Save(ctx context.Context, jobs []*job.Job) error {
	ret := _m.Called(ctx, jobs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*job.Job) error); ok {
		r0 = rf(ctx, jobs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewJobRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewJobRepository creates a new instance of JobRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewJobRepository(t mockConstructorTestingTNewJobRepository) *JobRepository {
	mock := &JobRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
