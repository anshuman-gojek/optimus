package v1beta1_test

import (
	"context"
	pb "github.com/odpf/optimus/protos/odpf/optimus/core/v1beta1"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/odpf/optimus/core/job"
	"github.com/odpf/optimus/core/job/handler/v1beta1"
	"github.com/odpf/optimus/core/tenant"
	"github.com/odpf/optimus/models"
)

func TestNewJobHandler(t *testing.T) {
	ctx := context.Background()
	project, _ := tenant.NewProject("test-proj",
		map[string]string{
			"bucket":                     "gs://some_folder-2",
			tenant.ProjectSchedulerHost:  "host",
			tenant.ProjectStoragePathKey: "gs://location",
		})
	namespace, _ := tenant.NewNamespace("test-ns", project.Name(),
		map[string]string{
			"bucket": "gs://ns_bucket",
		})
	sampleTenant, _ := tenant.NewTenant(project.Name().String(), namespace.Name().String())
	jobVersion := 1
	jobSchedule := job.NewSchedule("2022-10-01", "", "", false, false, nil)
	jobWindow, _ := models.NewWindow(jobVersion, "d", "24h", "24h")
	jobTaskConfig := job.NewConfig(map[string]string{"sample_task_key": "sample_value"})
	jobTask := job.NewTask("bq2bq", jobTaskConfig)

	t.Run("AddJobSpecifications", func(t *testing.T) {
		t.Run("adds job and returns deployment ID", func(t *testing.T) {
			jobService := NewJobService(t)

			jobHandler := v1beta1.NewJobHandler(jobService)

			jobSpecProto := &pb.JobSpecification{
				Version:          int32(jobVersion),
				Name:             "job-A",
				StartDate:        jobSchedule.StartDate(),
				EndDate:          jobSchedule.EndDate(),
				Interval:         jobSchedule.Interval(),
				TaskName:         jobTask.Name(),
				WindowSize:       jobWindow.GetSize(),
				WindowOffset:     jobWindow.GetOffset(),
				WindowTruncateTo: jobWindow.GetTruncateTo(),
			}
			jobProtos := []*pb.JobSpecification{jobSpecProto}
			request := pb.AddJobSpecificationsRequest{
				ProjectName:   project.Name().String(),
				NamespaceName: namespace.Name().String(),
				Specs:         jobProtos,
			}

			deploymentID := uuid.New()
			jobService.On("Add", ctx, sampleTenant, mock.Anything).Return(deploymentID, nil, nil)

			resp, err := jobHandler.AddJobSpecifications(ctx, &request)
			assert.Nil(t, err)
			assert.Equal(t, &pb.AddJobSpecificationsResponse{
				Log:          "jobs are created and queued for deployment on project test-proj",
				DeploymentId: deploymentID.String(),
			}, resp)
		})
	})
}

// JobService is an autogenerated mock type for the JobService type
type JobService struct {
	mock.Mock
}

// Add provides a mock function with given fields: ctx, jobTenant, jobs
func (_m *JobService) Add(ctx context.Context, jobTenant tenant.Tenant, jobs []*job.JobSpec) (uuid.UUID, error, error) {
	ret := _m.Called(ctx, jobTenant, jobs)

	var r0 uuid.UUID
	if rf, ok := ret.Get(0).(func(context.Context, tenant.Tenant, []*job.JobSpec) uuid.UUID); ok {
		r0 = rf(ctx, jobTenant, jobs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, tenant.Tenant, []*job.JobSpec) error); ok {
		r1 = rf(ctx, jobTenant, jobs)
	} else {
		r1 = ret.Error(1)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, tenant.Tenant, []*job.JobSpec) error); ok {
		r2 = rf(ctx, jobTenant, jobs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Validate provides a mock function with given fields: ctx, jobs
func (_m *JobService) Validate(ctx context.Context, jobs []*job.JobSpec) ([]*job.JobSpec, error) {
	ret := _m.Called(ctx, jobs)

	var r0 []*job.JobSpec
	if rf, ok := ret.Get(0).(func(context.Context, []*job.JobSpec) []*job.JobSpec); ok {
		r0 = rf(ctx, jobs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*job.JobSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []*job.JobSpec) error); ok {
		r1 = rf(ctx, jobs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewJobService interface {
	mock.TestingT
	Cleanup(func())
}

// NewJobService creates a new instance of JobService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewJobService(t mockConstructorTestingTNewJobService) *JobService {
	mock := &JobService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
